

--- index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Drive Clone - Improved</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- UI Elements -->
    <div id="ui-container">
        <div id="info">
            Use W/S/A/D or Arrow Keys to drive.<br>
            R to reset car position.<br>
            (Auto-resets if flipped)
        </div>
        <div id="stats-container">
            <div id="speedometer">Speed: <span id="speed-value">0</span> km/h</div>
            <div id="distance-meter">Distance: <span id="distance-value">0</span></div>
        </div>
    </div>

    <canvas id="c"></canvas>

    <!-- IMPORTANT: Use leading slash if using Vite -->
    <script type="module" src="/js/main.js"></script>
</body>
</html>


--- js\InputManager.js ---

// js/InputManager.js

export class InputManager {
    constructor() {
        this.keys = {};
        this.keyMap = {
            // Arrow Keys
            ArrowUp: 'forward',
            ArrowDown: 'backward',
            ArrowLeft: 'left',
            ArrowRight: 'right',
            // WASD Keys
            KeyW: 'forward',
            KeyS: 'backward',
            KeyA: 'left',
            KeyD: 'right',
            // Reset
            KeyR: 'reset'
        };

        // Using arrow functions to maintain 'this' context
        this._handleKeyDown = this._handleKeyDown.bind(this);
        this._handleKeyUp = this._handleKeyUp.bind(this);

        window.addEventListener('keydown', this._handleKeyDown);
        window.addEventListener('keyup', this._handleKeyUp);

        console.log("InputManager initialized.");
    }

    _handleKeyDown(event) {
        this.onKeyChange(event, true);
    }

    _handleKeyUp(event) {
        this.onKeyChange(event, false);
    }

    onKeyChange(event, isPressed) {
        const keyAction = this.keyMap[event.code];
        // console.log(`InputManager: Key=${event.code}, Action=${keyAction}, Pressed=${isPressed}`); // Keep for debugging if needed
        if (keyAction) {
            this.keys[keyAction] = isPressed;
            // Prevent default browser actions (like scrolling with arrow keys)
            // Only prevent if the key is mapped to an action
            event.preventDefault();
        }
    }

    isPressed(action) {
        return this.keys[action] || false;
    }

    // Optional: Add a dispose method to clean up listeners if the game were to be destroyed
    dispose() {
        window.removeEventListener('keydown', this._handleKeyDown);
        window.removeEventListener('keyup', this._handleKeyUp);
        this.keys = {}; // Clear keys
        console.log("InputManager disposed.");
    }
}


--- js\main.js ---

// js/main.js

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
// Note: Not using GSSolver here, relying on default + iterations + compound shape
import CannonDebugger from 'cannon-es-debugger';

import { Vehicle } from './Vehicle.js';
import { World } from './World.js';
import { InputManager } from './InputManager.js';
import { setupBackground, dampingFactor } from './utils.js';

// --- Performance / Debug Flags ---
const USE_PHYSICS_DEBUGGER = true; // Set to true to see physics wireframes

// --- Physics Settings ---
const PHYSICS_FIXED_TIMESTEP = 1 / 60;
const PHYSICS_MAX_SUBSTEPS = 8;
const SOLVER_ITERATIONS = 25; // Keep iterations high for stability

class Game {
    constructor() {
        this.renderer = null; this.scene = null; this.camera = null;
        this.physicsWorld = null; this.clock = null; this.inputManager = null;
        this.vehicle = null; this.world = null;
        this.physicsDebugger = null;
        this.cameraTarget = new THREE.Vector3();
        this.cameraPosition = new THREE.Vector3();
        this.speedElement = document.getElementById('speed-value');
        this.distanceElement = document.getElementById('distance-value');
        this.animate = this.animate.bind(this);
        this.onWindowResize = this.onWindowResize.bind(this);
        this.init();
    }

    init() {
        console.log("Initializing Game...");
        this.clock = new THREE.Clock();
        this.inputManager = new InputManager();

        const canvas = document.querySelector('#c');
        if (!canvas) { this.showError("Canvas element #c not found!"); return; }
        this.renderer = new THREE.WebGLRenderer({
            antialias: true, canvas: canvas, powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        this.scene = new THREE.Scene();
        setupBackground(this.scene, this.renderer);

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 1000);
        this.camera.position.set(0, 8, -12); // Initial camera position
        this.camera.lookAt(0, 0, 0);
        this.cameraPosition.copy(this.camera.position);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(40, 50, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        const shadowCamSize = 60;
        directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 150;
        directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize;
        directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize;
        directionalLight.shadow.bias = -0.001;
        this.scene.add(directionalLight);
        this.scene.add(directionalLight.target);

        this.physicsWorld = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0),
            broadphase: new CANNON.SAPBroadphase(this.physicsWorld),
            allowSleep: true,
        });
        this.physicsWorld.solver.iterations = SOLVER_ITERATIONS;
        this.physicsWorld.defaultContactMaterial.contactEquationStiffness = 1e8; // Base stiffness
        this.physicsWorld.defaultContactMaterial.contactEquationRelaxation = 3;
        this.physicsWorld.defaultContactMaterial.friction = 0.3;
        this.physicsWorld.defaultContactMaterial.restitution = 0.1;

        if (USE_PHYSICS_DEBUGGER) {
            this.physicsDebugger = new CannonDebugger(this.scene, this.physicsWorld, { color: 0x00ff00, scale: 1.0 });
            console.log("CannonDebugger initialized.");
        }

        try { this.world = new World(this.scene, this.physicsWorld); }
        catch (error) { this.showError(`Failed to initialize World:\n${error.stack}`); return; }

        try {
            const startPosition = new THREE.Vector3(0, 5, 0);
            this.vehicle = new Vehicle(this.scene, this.physicsWorld, this.inputManager, startPosition);
        } catch (error) { this.showError(`Failed to initialize Vehicle:\n${error.stack}`); return; }

        window.addEventListener('resize', this.onWindowResize);
        console.log("Initialization complete. Starting animation loop.");
        this.animate();
    }

    onWindowResize() {
        if (!this.camera || !this.renderer) return;
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    updateCamera(dt) {
        if (!this.vehicle || !this.vehicle.chassisGroup || !this.vehicle.chassisBody) return;

        const carChassisGroup = this.vehicle.chassisGroup;
        const carPosition = this.vehicle.getPosition(); // Use getter for consistency

        // Camera offset relative to car's local space (X: Forward/Backward, Y: Up/Down, Z: Left/Right)
        const relativeCameraOffset = new THREE.Vector3(-10, 5, 0); // Behind, Up, Centered

        // Look-at target relative to car's local space
        const lookAtTargetOffset = new THREE.Vector3(5, 1.5, 0); // Ahead, Slightly Up, Centered

        // Calculate world positions
        const cameraOffset = relativeCameraOffset.clone().applyQuaternion(carChassisGroup.quaternion).add(carPosition);
        const worldLookAtTarget = lookAtTargetOffset.clone().applyQuaternion(carChassisGroup.quaternion).add(carPosition);

        // Smooth interpolation
        const posLerpFactor = dampingFactor(0.03, dt);
        const targetLerpFactor = dampingFactor(0.05, dt);

        // Prevent camera going too low relative to car
        const minCameraHeightAboveCar = 1.5;
        if (cameraOffset.y < carPosition.y + minCameraHeightAboveCar) {
             cameraOffset.y = carPosition.y + minCameraHeightAboveCar;
        }

        this.cameraPosition.lerp(cameraOffset, posLerpFactor);
        this.cameraTarget.lerp(worldLookAtTarget, targetLerpFactor);

        this.camera.position.copy(this.cameraPosition);
        this.camera.lookAt(this.cameraTarget);

        // Update light target
        const light = this.scene.children.find(c => c instanceof THREE.DirectionalLight);
        if (light) {
            light.target.position.copy(this.cameraTarget);
            light.target.updateMatrixWorld();
        }
    }

    updateUI() {
        if (this.vehicle) {
            if (this.speedElement) this.speedElement.textContent = this.vehicle.getCurrentSpeedKmH();
            if (this.distanceElement) {
                const distMeters = this.vehicle.getDistanceTraveled('meters');
                this.distanceElement.textContent = (distMeters < 1000) ? `${distMeters} m` : `${this.vehicle.getDistanceTraveled('km')} km`;
            }
        }
    }

    animate() {
        requestAnimationFrame(this.animate);
        const dt = Math.min(this.clock.getDelta(), 0.1);

        if (this.physicsWorld) {
            try { this.physicsWorld.step(PHYSICS_FIXED_TIMESTEP, dt, PHYSICS_MAX_SUBSTEPS); }
            catch (error) { console.error("Physics step failed:", error); }
        }

        if (this.vehicle) this.vehicle.update(dt);
        // if (this.world) this.world.update(this.vehicle.getPosition()); // If world needed updates

        this.updateCamera(dt);
        this.updateUI();
        if (this.physicsDebugger) this.physicsDebugger.update();

        if (this.renderer) this.renderer.render(this.scene, this.camera);
    }

    showError(message) {
        console.error("GAME ERROR:", message); // Log full error too
        const errorDivId = 'game-error-message';
        let errorDiv = document.getElementById(errorDivId);
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.id = errorDivId;
            errorDiv.style.position = 'absolute'; errorDiv.style.top = '0'; errorDiv.style.left = '0';
            errorDiv.style.width = '100%'; errorDiv.style.padding = '20px';
            errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)'; errorDiv.style.color = 'white';
            errorDiv.style.fontFamily = 'monospace'; errorDiv.style.whiteSpace = 'pre-wrap';
            errorDiv.style.zIndex = '1000'; errorDiv.style.boxSizing = 'border-box';
            document.body.appendChild(errorDiv);
        }
        errorDiv.textContent = `ERROR:\n${message}\n\nPlease check the console (F12) for more details.`;
        // Optionally hide canvas/UI
        // document.getElementById('c')?.style.display = 'none';
        // document.getElementById('ui-container')?.style.display = 'none';
    }

    dispose() {
        console.log("Disposing game...");
        // Cancel animation frame if ID stored
        window.removeEventListener('resize', this.onWindowResize);
        if (this.inputManager) this.inputManager.dispose();
        if (this.vehicle) this.vehicle.dispose();
        if (this.world) this.world.dispose();
        if (this.renderer) this.renderer.dispose();
        // Nullify references
        Object.keys(this).forEach(key => this[key] = null);
    }
}

// --- Global Error Handling ---
window.addEventListener('error', (event) => {
    console.error("Unhandled global error:", event.error);
    window.gameInstance?.showError(`Unhandled Error: ${event.message}\n${event.error?.stack}`);
});
window.addEventListener('unhandledrejection', (event) => {
    console.error("Unhandled promise rejection:", event.reason);
    window.gameInstance?.showError(`Unhandled Promise Rejection: ${event.reason?.message}\n${event.reason?.stack}`);
});

// --- Start the Game ---
window.addEventListener('DOMContentLoaded', () => {
    console.log("DOM Loaded. Initializing Game...");
    try { window.gameInstance = new Game(); }
    catch (error) {
        console.error("Fatal error during game initialization:", error);
        document.body.innerHTML = `<div style="color: red; background: black; padding: 20px; font-family: monospace; white-space: pre-wrap; position: absolute; top:0; left:0; width: 100%; z-index: 1000; box-sizing: border-box;">FATAL ERROR initializing game. Check console (F12) for details. <br><br>${error.stack}</div>`;
    }
});


--- js\utils.js ---

// js/utils.js

// Import THREE locally, assuming it's installed via npm/yarn
import * as THREE from 'three';

/**
 * Linear interpolation between two values.
 * @param {number} start Start value.
 * @param {number} end End value.
 * @param {number} t Interpolation factor (0.0 to 1.0).
 * @returns {number} Interpolated value.
 */
export function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}

/**
 * Calculates a frame-rate independent damping factor for lerp.
 * @param {number} decayFactor How much percentage remains after 1 second (e.g., 0.01 for 1%).
 * @param {number} dt Delta time in seconds.
 * @returns {number} The lerp factor to use for this frame.
 */
export function dampingFactor(decayFactor, dt) {
    // Ensure decayFactor is within a reasonable range to avoid Math.pow issues
    const clampedDecay = Math.max(1e-9, Math.min(1.0, decayFactor));
    // Calculate the lerp amount needed this frame to achieve the desired decay over 1 second
    return 1.0 - Math.pow(clampedDecay, dt);
}

/**
 * Sets up the scene's background color and fog.
 * @param {THREE.Scene} scene The Three.js scene object.
 * @param {THREE.WebGLRenderer} renderer The Three.js renderer (optional, needed for env map).
 */
export function setupBackground(scene, renderer) {
    const skyColor = 0x0a0a32; // A lighter sky blue
    const groundColor = 0xB8860B; // DarkGoldenrod like color for fog blend

    scene.background = new THREE.Color(skyColor);
    // Fog( color, near, far ) - Adjust near/far for desired effect
    scene.fog = new THREE.Fog(skyColor, 50, 300);

    // --- Optional: Add Hemisphere Light for softer ambient lighting ---
    const hemiLight = new THREE.HemisphereLight(skyColor, groundColor, 0.6); // Sky, Ground, Intensity
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);


    // --- Optional Skybox (keep commented unless you have the assets) ---
    /*
    const loader = new THREE.CubeTextureLoader();
    // Make sure you have these images in a 'public/skybox/' folder (or adjust path)
    const texture = loader.setPath('skybox/').load([
        'px.jpg', // Right
        'nx.jpg', // Left
        'py.jpg', // Top
        'ny.jpg', // Bottom
        'pz.jpg', // Front
        'nz.jpg'  // Back
    ]);
    scene.background = texture;
    // Apply as environment map for reflections (requires materials supporting env maps)
    // scene.environment = texture;
    */
}


--- js\Vehicle.js ---

// js/Vehicle.js

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { lerp, dampingFactor } from './utils.js';

// --- Vehicle Physics Constants ---
// Engine & Brakes
const ENGINE_FORCE_FORWARD = 500;
const ENGINE_FORCE_BACKWARD = 200;
const BRAKE_FORCE = 10;

// Steering
const MAX_STEER_ANGLE = Math.PI / 6.0;

// Suspension & Wheels
const SUSPENSION_STIFFNESS = 35;
const SUSPENSION_DAMPING = 5;
const SUSPENSION_COMPRESSION = 5;
const SUSPENSION_REST_LENGTH = 0.45;
const SUSPENSION_TRAVEL = 0.5;
const FRICTION_SLIP = 2.2;
const WHEEL_RADIUS = 0.4;
const WHEEL_WIDTH = 0.3;

// Chassis Physics Body Properties
const CHASSIS_MASS = 160;
const CHASSIS_LINEAR_DAMPING = 0.25;
const CHASSIS_ANGULAR_DAMPING = 0.7;

// --- Flip Detection Constants ---
const FLIP_THRESHOLD_DOT = 0.3; // Dot product threshold (car_up . world_up)
const FLIP_RESET_DELAY = 2.5; // Seconds the car must be flipped before auto-reset

export class Vehicle {
    constructor(scene, physicsWorld, inputManager, startPos = new THREE.Vector3(0, 5, 0)) {
        this.scene = scene;
        this.physicsWorld = physicsWorld;
        this.inputManager = inputManager;
        this.startPosCannon = new CANNON.Vec3(startPos.x, startPos.y, startPos.z);
        this.startPosThree = startPos.clone();

        // Vehicle dimensions
        this.chassisWidth = 1.7;
        this.chassisHeight = 0.5; // Main physics box height
        this.chassisLength = 2.8;
        this.wheelRadius = WHEEL_RADIUS;
        this.wheelWidth = WHEEL_WIDTH;

        // Physics objects
        this.vehicle = null;
        this.chassisBody = null; // This will be the Compound body

        // Visual objects
        this.chassisGroup = null;
        this.wheelMeshes = [];

        // State
        this.currentSteering = 0;
        this.totalDistance = 0;
        this.previousPosition = this.startPosThree.clone();

        // Flip state
        this.isFlipped = false;
        this.timeFlipped = 0;

        this.createPhysicsVehicle(); // Creates compound body now
        this.createVisualVehicle();

        console.log("Vehicle initialized.");
    }

    createPhysicsVehicle() {
        // --- Create Shapes for Compound Body ---
        // 1. Main Chassis Box (visual representation)
        const mainBoxExtents = new CANNON.Vec3(this.chassisLength * 0.5, this.chassisHeight * 0.5, this.chassisWidth * 0.5);
        const mainBoxShape = new CANNON.Box(mainBoxExtents);
        const mainBoxOffset = new CANNON.Vec3(0, 0, 0); // Centered

        // 2. Skid Plate Box (for better ground contact stability)
        const skidHeight = 0.05; // Very thin
        const skidWidth = this.chassisWidth * 0.95; // Almost full width
        const skidLength = this.chassisLength * 0.9; // Almost full length
        const skidPlateExtents = new CANNON.Vec3(skidLength * 0.5, skidHeight * 0.5, skidWidth * 0.5);
        const skidPlateShape = new CANNON.Box(skidPlateExtents);
        // Position it slightly below the main chassis box center
        const skidPlateOffsetY = -mainBoxExtents.y - skidHeight * 0.5 + 0.01; // Place just below the main box bottom
        const skidPlateOffset = new CANNON.Vec3(0, skidPlateOffsetY, 0);

        // --- Create Compound Body ---
        this.chassisBody = new CANNON.Body({
            mass: CHASSIS_MASS,
            material: this.physicsWorld.defaultMaterial, // Assign material here
            position: this.startPosCannon,
            angularVelocity: new CANNON.Vec3(0, 0, 0),
            linearDamping: CHASSIS_LINEAR_DAMPING,
            angularDamping: CHASSIS_ANGULAR_DAMPING,
        });

        // --- Add Shapes to the Compound Body ---
        this.chassisBody.addShape(mainBoxShape, mainBoxOffset);
        this.chassisBody.addShape(skidPlateShape, skidPlateOffset);

        this.chassisBody.allowSleep = false; // Keep vehicle active

        // --- Raycast Vehicle Setup (uses the compound body) ---
        this.vehicle = new CANNON.RaycastVehicle({
            chassisBody: this.chassisBody,
            indexRightAxis: 2,    // Z is right
            indexForwardAxis: 0,  // X is forward
            indexUpAxis: 1,       // Y is up
        });

        // --- Wheel Setup ---
        const wheelOptions = {
            radius: this.wheelRadius,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: SUSPENSION_STIFFNESS,
            suspensionRestLength: SUSPENSION_REST_LENGTH,
            frictionSlip: FRICTION_SLIP,
            dampingRelaxation: SUSPENSION_DAMPING,
            dampingCompression: SUSPENSION_COMPRESSION,
            maxSuspensionForce: 100000,
            maxSuspensionTravel: SUSPENSION_TRAVEL,
            customSlidingRotationalSpeed: -35,
            useCustomSlidingRotationalSpeed: true,
            axleLocal: new CANNON.Vec3(0, 0, 1), // Z-axis for axle rotation
            chassisConnectionPointLocal: new CANNON.Vec3(), // Set per wheel
            isFrontWheel: false,
        };

        // Wheel positions (relative to the compound body's center 0,0,0)
        const axleWidth = this.chassisWidth * 0.45;
        const frontAxlePos = this.chassisLength * 0.4;
        const rearAxlePos = -this.chassisLength * 0.4;
        // Connect wheels relative to the main box's approximate bottom edge height
        const connectionHeight = -this.chassisHeight * 0.4; // Relative to body center (0,0,0)

        // Front Left (Index 0)
        wheelOptions.chassisConnectionPointLocal.set(frontAxlePos, connectionHeight, axleWidth);
        wheelOptions.isFrontWheel = true; this.vehicle.addWheel({ ...wheelOptions });
        // Front Right (Index 1)
        wheelOptions.chassisConnectionPointLocal.set(frontAxlePos, connectionHeight, -axleWidth);
        wheelOptions.isFrontWheel = true; this.vehicle.addWheel({ ...wheelOptions });
        // Rear Left (Index 2)
        wheelOptions.chassisConnectionPointLocal.set(rearAxlePos, connectionHeight, axleWidth);
        wheelOptions.isFrontWheel = false; this.vehicle.addWheel({ ...wheelOptions });
        // Rear Right (Index 3)
        wheelOptions.chassisConnectionPointLocal.set(rearAxlePos, connectionHeight, -axleWidth);
        wheelOptions.isFrontWheel = false; this.vehicle.addWheel({ ...wheelOptions });

        // Add RaycastVehicle specific constraints/logic to the physics world
        this.vehicle.addToWorld(this.physicsWorld);

        console.log("Physics vehicle created with Compound shape.");
    }

    createVisualVehicle() {
        // Visuals remain the same, based on the main chassis dimensions
        this.chassisGroup = new THREE.Group();
        this.scene.add(this.chassisGroup);

        const bodyHeight = 0.4;
        const bodyOffsetY = 0.1;
        const bodyGeo = new THREE.BoxGeometry(this.chassisLength, bodyHeight, this.chassisWidth);
        const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xcc0000, metalness: 0.7, roughness: 0.3, flatShading: false
        });
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = false;
        bodyMesh.position.y = bodyOffsetY;
        this.chassisGroup.add(bodyMesh);

        const cabinLength = this.chassisLength * 0.45;
        const cabinWidth = this.chassisWidth * 0.8;
        const cabinHeight = 0.5;
        const cabinGeo = new THREE.BoxGeometry(cabinLength, cabinHeight, cabinWidth);
        const cabinMat = new THREE.MeshStandardMaterial({
            color: 0x444444, metalness: 0.1, roughness: 0.7, flatShading: false
        });
        const cabinMesh = new THREE.Mesh(cabinGeo, cabinMat);
        cabinMesh.castShadow = true;
        cabinMesh.receiveShadow = true;
        cabinMesh.position.y = bodyOffsetY + bodyHeight / 2 + cabinHeight / 2;
        cabinMesh.position.x = -this.chassisLength * 0.15;
        this.chassisGroup.add(cabinMesh);

        const wheelGeo = new THREE.CylinderGeometry(this.wheelRadius, this.wheelRadius, this.wheelWidth, 24);
        wheelGeo.rotateX(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({
            color: 0x222222, metalness: 0.1, roughness: 0.8, flatShading: false
        });

        for (let i = 0; i < 4; i++) {
            const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
            wheelMesh.castShadow = true;
            wheelMesh.receiveShadow = true;
            this.scene.add(wheelMesh);
            this.wheelMeshes.push(wheelMesh);
        }
    }

    update(dt) {
        if (!this.vehicle || !this.chassisBody || !this.chassisGroup) return;

        // --- Check for Flip Condition & Auto-Reset ---
        this.checkFlipCondition(dt);
        // If reset was triggered by flip check, this.isFlipped will be false after resetPosition runs
        // No explicit return needed here as resetPosition handles state

        // --- Track Distance ---
        const currentPosition = this.getPosition();
        const dx = currentPosition.x - this.previousPosition.x;
        const dz = currentPosition.z - this.previousPosition.z;
        this.totalDistance += Math.sqrt(dx * dx + dz * dz);
        this.previousPosition.copy(currentPosition);

        // --- Input Handling ---
        let engineForce = 0;
        let brakeForce = 0;
        let targetSteering = 0;

        const forwardPressed = this.inputManager.isPressed('forward');
        const backwardPressed = this.inputManager.isPressed('backward');
        const leftPressed = this.inputManager.isPressed('left');
        const rightPressed = this.inputManager.isPressed('right');

        if (forwardPressed) {
            engineForce = ENGINE_FORCE_FORWARD;
        } else if (backwardPressed) {
            const currentSpeed = this.chassisBody.velocity.length();
            const worldVelocity = this.chassisBody.velocity;
            const forwardDir = new CANNON.Vec3();
            this.chassisBody.vectorToWorldFrame(new CANNON.Vec3(1, 0, 0), forwardDir);
            const dot = forwardDir.dot(worldVelocity.unit());

            if (dot > 0.1 && currentSpeed > 0.5) {
                brakeForce = BRAKE_FORCE; engineForce = 0;
            } else {
                engineForce = -ENGINE_FORCE_BACKWARD; brakeForce = 0;
            }
        }

        if (leftPressed) { targetSteering = MAX_STEER_ANGLE; }
        else if (rightPressed) { targetSteering = -MAX_STEER_ANGLE; }
        else { targetSteering = 0; }

        // --- Smooth Steering ---
        const steerLerpFactor = dampingFactor(0.1, dt);
        this.currentSteering = lerp(this.currentSteering, targetSteering, steerLerpFactor);
        this.currentSteering = Math.max(-MAX_STEER_ANGLE, Math.min(MAX_STEER_ANGLE, this.currentSteering));

        // --- Apply Physics ---
        this.vehicle.applyEngineForce(engineForce, 2);
        this.vehicle.applyEngineForce(engineForce, 3);
        for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
            this.vehicle.setBrake(brakeForce, i);
        }
        this.vehicle.setSteeringValue(this.currentSteering, 0);
        this.vehicle.setSteeringValue(this.currentSteering, 1);

        // --- Reset (Manual) ---
        if (this.inputManager.isPressed('reset')) {
            this.resetPosition();
            return; // Skip visual update this frame after manual reset
        }

        // --- Update Visuals ---
        this.chassisGroup.position.copy(this.chassisBody.position);
        this.chassisGroup.quaternion.copy(this.chassisBody.quaternion);

        for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
            this.vehicle.updateWheelTransform(i);
            const transform = this.vehicle.wheelInfos[i].worldTransform;
            const wheelMesh = this.wheelMeshes[i];
            if (wheelMesh) {
                wheelMesh.position.copy(transform.position);
                wheelMesh.quaternion.copy(transform.quaternion);
            }
        }
    }

    checkFlipCondition(dt) {
        if (!this.chassisBody) return;

        const localUp = new CANNON.Vec3(0, 1, 0);
        const worldUp = new CANNON.Vec3();
        this.chassisBody.vectorToWorldFrame(localUp, worldUp);
        const worldTrueUp = new CANNON.Vec3(0, 1, 0);
        const dotProduct = worldUp.dot(worldTrueUp);

        if (dotProduct < FLIP_THRESHOLD_DOT) {
            if (!this.isFlipped) {
                this.isFlipped = true;
                this.timeFlipped = 0;
                console.log("Vehicle flipped!");
            }
            this.timeFlipped += dt;

            if (this.timeFlipped >= FLIP_RESET_DELAY) {
                console.log("Vehicle flipped too long, auto-resetting...");
                this.resetPosition(); // Resets isFlipped and timeFlipped internally
            }
        } else {
            if (this.isFlipped) {
                 console.log("Vehicle recovered from flip.");
            }
            this.isFlipped = false;
            this.timeFlipped = 0;
        }
    }

    resetPosition() {
        if (!this.vehicle || !this.chassisBody) return;
        console.log("Resetting vehicle position...");

        // Reset physics state
        this.chassisBody.position.copy(this.startPosCannon);
        this.chassisBody.quaternion.set(0, 0, 0, 1);
        this.chassisBody.velocity.set(0, 0, 0);
        this.chassisBody.angularVelocity.set(0, 0, 0);

        // Reset vehicle controls state
        this.vehicle.applyEngineForce(0, 2); this.vehicle.applyEngineForce(0, 3);
        this.vehicle.setSteeringValue(0, 0); this.vehicle.setSteeringValue(0, 1);
        this.currentSteering = 0;
        for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
            this.vehicle.setBrake(BRAKE_FORCE * 2, i); // Apply brakes momentarily
        }

        // Reset flip state
        this.isFlipped = false;
        this.timeFlipped = 0;

        // Reset distance tracking
        this.totalDistance = 0;
        this.previousPosition.copy(this.startPosThree);

        this.chassisBody.wakeUp();

        // Release brakes after a short delay
        setTimeout(() => {
            if (this.vehicle) { // Check if vehicle still exists
                for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
                    this.vehicle.setBrake(0, i);
                }
                console.log("Brakes released after reset.");
            }
        }, 150);
    }

    getPosition() {
        if (!this.chassisBody) return this.startPosThree.clone();
        return new THREE.Vector3(
            this.chassisBody.position.x, this.chassisBody.position.y, this.chassisBody.position.z
        );
    }

    getCurrentSpeedKmH() {
        if (!this.chassisBody) return 0;
        return Math.round(this.chassisBody.velocity.length() * 3.6);
    }

    getDistanceTraveled(unit = 'meters') {
        switch (unit.toLowerCase()) {
            case 'kilometers': case 'km': return (this.totalDistance / 1000).toFixed(2);
            case 'miles': case 'mi': return (this.totalDistance / 1609.34).toFixed(2);
            case 'meters': case 'm': default: return Math.round(this.totalDistance);
        }
    }

    dispose() {
        console.log("Disposing vehicle...");
        if (this.vehicle) this.vehicle.removeFromWorld(this.physicsWorld);
        if (this.chassisBody) this.physicsWorld.removeBody(this.chassisBody);

        if (this.chassisGroup) {
            this.scene.remove(this.chassisGroup);
            this.chassisGroup.traverse(child => {
                if (child.isMesh) { child.geometry?.dispose(); child.material?.dispose(); }
            });
        }
        this.wheelMeshes.forEach(mesh => {
            this.scene.remove(mesh);
            mesh.geometry?.dispose(); mesh.material?.dispose();
        });

        this.wheelMeshes = []; this.vehicle = null; this.chassisBody = null; this.chassisGroup = null;
    }
}


--- js\World.js ---

// js/World.js

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { createNoise2D } from 'simplex-noise';

// --- Terrain Constants ---
const TERRAIN_SIZE = 800;
const TERRAIN_RESOLUTION = 128;
const HALF_SIZE = TERRAIN_SIZE / 2;

// --- Noise Parameters ---
const NOISE_HEIGHT_SCALE = 1.0;
const NOISE_HEIGHT_LARGE = 5 * NOISE_HEIGHT_SCALE;
const NOISE_HEIGHT_MEDIUM = 0.4 * NOISE_HEIGHT_SCALE;
const NOISE_HEIGHT_SMALL = 0.1 * NOISE_HEIGHT_SCALE;
const NOISE_SCALE_LARGE = 0.015;
const NOISE_SCALE_MEDIUM = 0.06;
const NOISE_SCALE_SMALL = 0.2;
const ROAD_FLATTEN_FACTOR = 0.1;

// --- Color Gradient ---
const COLOR_STOPS = [
    { h: -5, color: new THREE.Color(0x4466aa) }, { h: -0.5, color: new THREE.Color(0x6699cc) },
    { h: 0, color: new THREE.Color(0xdec070) }, { h: 1, color: new THREE.Color(0x558844) },
    { h: 4, color: new THREE.Color(0x776655) }, { h: 7, color: new THREE.Color(0xaaaaaa) },
    { h: 10, color: new THREE.Color(0xffffff) },
];

export class World {
    constructor(scene, physicsWorld) {
        this.scene = scene;
        this.physicsWorld = physicsWorld;
        this.noise = createNoise2D();

        this.terrainMesh = null;
        this.terrainBody = null;
        this.groundMaterial = null;
        this.terrainMaterial = null;

        this.createPhysicsMaterials();
        this.createVisualMaterial();
        this.createTerrain();
        // this.createDebugHelpers();

        console.log("World initialized.");
    }

    createPhysicsMaterials() {
        this.groundMaterial = new CANNON.Material('groundMaterial');
        // Find the default material used by other objects (like the vehicle)
        const defaultMaterial = this.physicsWorld.defaultContactMaterial.materials.find(m => m !== this.groundMaterial) || this.physicsWorld.defaultMaterial;


        const groundDefaultContactMaterial = new CANNON.ContactMaterial(
            this.groundMaterial,
            defaultMaterial,
            {
                friction: 1.0,           // High friction
                restitution: 0.0,        // No bounce
                contactEquationStiffness: 1e9, // High stiffness
                contactEquationRelaxation: 3,
                frictionEquationStiffness: 1e9, // High friction stiffness
                frictionEquationRelaxation: 3,
            }
        );
        this.physicsWorld.addContactMaterial(groundDefaultContactMaterial);
        console.log("Physics materials created for World (with increased stiffness/friction).");
    }

    createVisualMaterial() {
        this.terrainMaterial = new THREE.MeshStandardMaterial({
            flatShading: false,
            metalness: 0.05,
            roughness: 0.9,
            vertexColors: true
        });
        console.log("Visual material created for World.");
    }

    update(playerPosition) {
        // Static terrain
    }

    createDebugHelpers() {
        const originHelper = new THREE.Mesh(
            new THREE.SphereGeometry(1, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
        );
        originHelper.position.set(0, 0.1, 0);
        this.scene.add(originHelper);
        const axesHelper = new THREE.AxesHelper(10);
        this.scene.add(axesHelper);
        console.log("Debug helpers added.");
    }

    createTerrain() {
        console.log(`Generating terrain (${TERRAIN_RESOLUTION}x${TERRAIN_RESOLUTION})...`);
        const segmentSize = TERRAIN_SIZE / TERRAIN_RESOLUTION;

        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const colors = [];

        console.time("VertexGeneration");
        for (let z = 0; z <= TERRAIN_RESOLUTION; z++) {
            for (let x = 0; x <= TERRAIN_RESOLUTION; x++) {
                const worldX = -HALF_SIZE + x * segmentSize;
                const worldZ = -HALF_SIZE + z * segmentSize;
                const height = this.calculateHeight(worldX, worldZ);
                vertices.push(worldX, height, worldZ);
                const color = this.getColorForHeight(height);
                colors.push(color.r, color.g, color.b);
                if (x < TERRAIN_RESOLUTION && z < TERRAIN_RESOLUTION) {
                    const tl = z * (TERRAIN_RESOLUTION + 1) + x; const tr = tl + 1;
                    const bl = (z + 1) * (TERRAIN_RESOLUTION + 1) + x; const br = bl + 1;
                    indices.push(tl, bl, tr); indices.push(tr, bl, br);
                }
            }
        }
        console.timeEnd("VertexGeneration");

        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        console.time("NormalCalculation");
        geometry.computeVertexNormals();
        console.timeEnd("NormalCalculation");

        this.terrainMesh = new THREE.Mesh(geometry, this.terrainMaterial);
        this.terrainMesh.receiveShadow = true;
        this.scene.add(this.terrainMesh);
        console.log("Visual terrain mesh created.");

        console.log("Creating physics Trimesh...");
        console.time("TrimeshCreation");
        const trimeshVertices = Array.from(vertices);
        const trimeshIndices = Array.from(indices);
        const trimeshShape = new CANNON.Trimesh(trimeshVertices, trimeshIndices);

        this.terrainBody = new CANNON.Body({
            mass: 0,
            material: this.groundMaterial, // Use the specific ground material
            shape: trimeshShape,
        });
        this.terrainBody.position.set(0, 0, 0);
        this.physicsWorld.addBody(this.terrainBody);
        console.timeEnd("TrimeshCreation");
        console.log("Physics Trimesh body created.");
    }

    calculateHeight(worldX, worldZ) {
        let height = 0;
        height += this.noise(worldX * NOISE_SCALE_LARGE, worldZ * NOISE_SCALE_LARGE) * NOISE_HEIGHT_LARGE;
        height += this.noise(worldX * NOISE_SCALE_MEDIUM, worldZ * NOISE_SCALE_MEDIUM) * NOISE_HEIGHT_MEDIUM;
        height += this.noise(worldX * NOISE_SCALE_SMALL, worldZ * NOISE_SCALE_SMALL) * NOISE_HEIGHT_SMALL;
        const flatten = Math.exp(-Math.pow(height, 2) * ROAD_FLATTEN_FACTOR);
        height *= flatten;
        return height;
    }

    getColorForHeight(height) {
        let vertColor = new THREE.Color().copy(COLOR_STOPS[0].color);
        for (let i = 0; i < COLOR_STOPS.length - 1; i++) {
            const currentStop = COLOR_STOPS[i]; const nextStop = COLOR_STOPS[i + 1];
            if (height >= currentStop.h && height < nextStop.h) {
                const t = Math.max(0, Math.min(1, (height - currentStop.h) / (nextStop.h - currentStop.h)));
                vertColor.lerpColors(currentStop.color, nextStop.color, t);
                return vertColor;
            }
        }
        if (height >= COLOR_STOPS[COLOR_STOPS.length - 1].h) {
            vertColor.copy(COLOR_STOPS[COLOR_STOPS.length - 1].color);
        }
        return vertColor;
    }

    dispose() {
        console.log("Disposing world...");
        if (this.terrainBody) this.physicsWorld.removeBody(this.terrainBody);
        if (this.terrainMesh) {
            this.scene.remove(this.terrainMesh);
            this.terrainMesh.geometry.dispose();
            // this.terrainMaterial.dispose(); // Only if not shared
        }
        this.terrainBody = null; this.terrainMesh = null;
    }
}


--- style.css ---

body {
    margin: 0;
    overflow: hidden; /* Prevent scrollbars */
    background-color: #000;
    color: white;
    font-family: Arial, sans-serif;
}

#c {
    display: block; /* Remove potential extra space below canvas */
}

#ui-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    padding: 10px;
    box-sizing: border-box; /* Include padding in width */
    pointer-events: none; /* Allow clicking through UI */
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

#info {
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 0.9em;
    max-width: 200px; /* Limit width */
}

#stats-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 5px;
    font-weight: bold;
    min-width: 80px;
    text-align: center;
}

#speedometer, #distance-meter {
    font-size: 1.1em;
    font-weight: bold;
}


--- vite.config.js ---

// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    // Make sure this is correct for your development environment if needed
    // allowedHosts: ['scope-tent-tips-freebsd.trycloudflare.com'],
    host: true // Allows access from network devices (useful for testing on mobile)
  },
  // Optional: Optimize dependencies if needed, Vite usually handles this well
  // optimizeDeps: {
  //   include: ['three', 'cannon-es', 'cannon-es-debugger', 'simplex-noise'],
  // },
});
