

--- new\ayush\index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Drive Clone</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- UI Elements -->
    <div id="ui-container">
        <div id="info">
            Use W/S/A/D or Arrow Keys to drive.<br>
            R to reset car position.
        </div>
        <div id="stats-container">
            <div id="speedometer">
                Speed: <span id="speed-value">0</span> km/h
            </div>
            <div id="distance-meter">
                Distance: <span id="distance-value">0</span> m
            </div>
        </div>
    </div>

    <canvas id="c"></canvas>

    <!-- IMPORTANT: Use leading slash if using Vite -->
    <script type="module" src="/js/main.js"></script>
</body>
</html>


--- new\ayush\js\InputManager.js ---

export class InputManager {
    constructor() {
        this.keys = {};
        this.keyMap = {
            // Arrow Keys
            ArrowUp: 'forward',
            ArrowDown: 'backward',
            ArrowLeft: 'left',
            ArrowRight: 'right',
            // WASD Keys
            KeyW: 'forward',
            KeyS: 'backward',
            KeyA: 'left',
            KeyD: 'right',
            // Reset
            KeyR: 'reset'
        };

        window.addEventListener('keydown', (e) => this.onKeyChange(e, true));
        window.addEventListener('keyup', (e) => this.onKeyChange(e, false));
    }

    onKeyChange(event, isPressed) {
        const keyAction = this.keyMap[event.code];
        // *** ADD LOG ***
        console.log(`InputManager: Key=${event.code}, Action=${keyAction}, Pressed=${isPressed}`);
        if (keyAction) {
            this.keys[keyAction] = isPressed;
            event.preventDefault(); // Prevent default browser actions (scrolling)
        }
    }

    isPressed(action) {
        return this.keys[action] || false;
    }
}


--- new\ayush\js\main.js ---

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import CannonDebugger from 'cannon-es-debugger';

import { Vehicle } from './Vehicle.js';
import { World } from './World.js';
import { InputManager } from './InputManager.js';
import { setupBackground, dampingFactor } from './utils.js';

class Game {
    constructor() {
        this.renderer = null; this.scene = null; this.camera = null;
        this.physicsWorld = null; this.clock = null; this.inputManager = null;
        this.vehicle = null; this.world = null; this.physicsDebugger = null;

        this.cameraTarget = new THREE.Vector3();
        this.cameraPosition = new THREE.Vector3();

        this.speedElement = document.getElementById('speed-value');
        this.speedElement = document.getElementById('distance-value');

        this.animate = this.animate.bind(this);
        this.onWindowResize = this.onWindowResize.bind(this);

        this.init();
    }

    init() {
        this.clock = new THREE.Clock();
        this.inputManager = new InputManager();

        // --- Renderer ---
        const canvas = document.querySelector('#c');
        if (!canvas) { console.error("Canvas element #c not found!"); return; }
        this.renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.physicsWorld = new CANNON.World();
        this.physicsWorld.gravity.set(0, -9.82, 0);
        this.physicsWorld.broadphase = new CANNON.SAPBroadphase(this.physicsWorld);
        this.physicsWorld.allowSleep = false; // Disable sleep globally
        this.physicsWorld.solver.iterations = 20; // Increase iterations
        this.physicsWorld.defaultContactMaterial.contactEquationStiffness = 1e8;
        this.physicsWorld.defaultContactMaterial.contactEquationRelaxation = 3;


        // --- Scene ---
        this.scene = new THREE.Scene();
        setupBackground(this.scene, this.renderer);

        // --- Camera ---
        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Initial camera position might need slight adjustment based on new offset
        this.camera.position.set(0, 6, -10); // Slightly adjusted initial
        this.camera.lookAt(0, 0, 0);
        this.cameraPosition.copy(this.camera.position);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(50, 60, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -80;
        directionalLight.shadow.camera.right = 80;
        directionalLight.shadow.camera.top = 80;
        directionalLight.shadow.camera.bottom = -80;
        directionalLight.target.position.set(0, 0, 0);
        this.scene.add(directionalLight);
        this.scene.add(directionalLight.target);

        // --- Physics ---
        this.physicsWorld = new CANNON.World();
        this.physicsWorld.gravity.set(0, -9.82, 0);
        this.physicsWorld.broadphase = new CANNON.SAPBroadphase(this.physicsWorld);
        this.physicsWorld.allowSleep = true;
        this.physicsWorld.solver.iterations = 15;

        // --- Physics Debugger ---
        this.physicsDebugger = new CannonDebugger(this.scene, this.physicsWorld, {
            color: 0xff00ff, // Magenta wireframes
            scale: 1.0,
        });

        // --- World (Terrain using Heightfield) ---
        this.world = new World(this.scene, this.physicsWorld);

        // --- Vehicle ---
        const startPosition = new THREE.Vector3(0, 5, 0); // Start high enough
        this.vehicle = new Vehicle(this.scene, this.physicsWorld, this.inputManager, startPosition);

         // --- Initial World Update ---
         if (this.vehicle && this.vehicle.chassisBody) {
             this.world.update(this.vehicle.getPosition());
         } else {
              console.error("Vehicle not ready for initial world update.");
              this.world.update(new THREE.Vector3(0, 0, 0));
         }

        window.addEventListener('resize', this.onWindowResize);
        console.log("Initialization complete. Starting animation loop.");
        this.animate();
    }

    onWindowResize() {
        if (!this.camera || !this.renderer) return;
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    updateCamera(dt) {
        // *** CAR VISUAL CHANGE: Check for chassisGroup ***
         if (!this.vehicle || !this.vehicle.chassisGroup || !this.vehicle.chassisBody) return;

        // *** CAR VISUAL CHANGE: Use chassisGroup for matrix world ***
        const carChassisGroup = this.vehicle.chassisGroup;

        // *** CAMERA ADJUSTMENT: Lower Y, Closer X ***
        const relativeCameraOffset = new THREE.Vector3( -7, 4, 0); // Was (-8, 5, 0) - Closer and Lower
        const cameraOffset = relativeCameraOffset.clone().applyMatrix4(carChassisGroup.matrixWorld);

        // Adjust lookAt target if needed (looking slightly higher/further relative to car)
        const lookAtTargetOffset = new THREE.Vector3(4, 1.5, 0); // Look slightly higher
        const worldLookAtTarget = lookAtTargetOffset.clone().applyMatrix4(carChassisGroup.matrixWorld);

        // Damping factors for smooth camera movement
        const posLerpFactor = dampingFactor(0.02, dt);
        const targetLerpFactor = dampingFactor(0.01, dt);

        this.cameraPosition.lerp(cameraOffset, posLerpFactor);
        this.cameraTarget.lerp(worldLookAtTarget, targetLerpFactor);

        this.camera.position.copy(this.cameraPosition);
        this.camera.lookAt(this.cameraTarget);

        // Update light target
        const light = this.scene.children.find(c => c instanceof THREE.DirectionalLight);
        if (light) {
            light.target.position.copy(this.cameraTarget);
            light.target.updateMatrixWorld();
        }
    }

    updateUI() {
        if (this.vehicle && this.speedElement) {
            const speed = this.vehicle.getCurrentSpeedKmH();
            this.speedElement.textContent = speed;
        }
    }

    animate() {
         const dt = Math.min(this.clock.getDelta(), 0.05);
         requestAnimationFrame(this.animate);

        // --- Physics Update ---
        if (this.physicsWorld) {
            const fixedTimeStep = 1 / 60;
            const maxSubSteps = 10;  // Increased from 5
            try {
                this.physicsWorld.step(fixedTimeStep, dt, maxSubSteps);
            } catch (error) { console.error("Physics step failed:", error); }
        }

        // --- Game Object Updates ---
        if (this.vehicle) { this.vehicle.update(dt); }
        if (this.world && this.vehicle) { this.world.update(this.vehicle.getPosition()); }

        // --- Camera Update ---
        this.updateCamera(dt);

        // --- UI Update ---
        this.updateUI();

        // --- UPDATE PHYSICS DEBUGGER ---
        if (this.physicsDebugger) { this.physicsDebugger.update(); }

        // --- Render ---
        if (this.renderer && this.scene && this.camera) {
             this.renderer.render(this.scene, this.camera);
        }
    }
}

// Start the game
window.addEventListener('DOMContentLoaded', () => {
     console.log("DOM Loaded. Initializing Game...");
     try { new Game(); }
     catch(error) {
         console.error("Failed to initialize game:", error);
         document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace; white-space: pre-wrap;">Error initializing game. Check console (F12) for details. <br><br>${error.stack}</div>`;
     }
});


--- new\ayush\js\utils.js ---

// Import THREE directly from CDN
import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.min.js';

// Linear interpolation
export function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}

// Frame-rate independent damping (useful for lerp factor)
// decayFactor: How much remains after 1 second (e.g., 0.01 means 1% remains)
// dt: delta time in seconds
export function dampingFactor(decayFactor, dt) {
    return 1.0 - Math.pow(decayFactor, dt);
}

// Setup background color, fog, and optional skybox
export function setupBackground(scene, renderer) { // Pass renderer if needed for env map
    const skyColor = 0xade0ee; // Light blueish sky
    scene.background = new THREE.Color(skyColor);
    scene.fog = new THREE.Fog(skyColor, 60, 250); // Adjust fog distances

    // --- Optional Skybox ---
    /*
    const loader = new THREE.CubeTextureLoader();
    // Make sure you have these images in a 'skybox' folder relative to your public directory
    const texture = loader.setPath('skybox/').load([
        'px.jpg', // Right
        'nx.jpg', // Left
        'py.jpg', // Top
        'ny.jpg', // Bottom
        'pz.jpg', // Front
        'nz.jpg'  // Back
    ]);
    scene.background = texture;
    // Optional: Apply as environment map for reflections (requires materials to be adjusted)
    // scene.environment = texture;
    */
}


--- new\ayush\js\Vehicle.js ---

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { lerp } from './utils.js'; // Removed dampingFactor import as it's not used here

// --- Constants --- Tuned for Heightfield
const ENGINE_FORCE_FORWARD = 300;
const ENGINE_FORCE_BACKWARD = 200;
const BRAKE_FORCE = 60;
const MAX_STEER_ANGLE = Math.PI / 6.5;
const STEERING_SPEED = 4.0;
const SUSPENSION_STIFFNESS = 30;
const SUSPENSION_DAMPING = 5;
const SUSPENSION_COMPRESSION = 4;
const SUSPENSION_REST_LENGTH = 0.5;
const SUSPENSION_TRAVEL = 0.4;
const FRICTION_SLIP = 1.8;
const WHEEL_RADIUS = 0.4;
const WHEEL_WIDTH = 0.25;

export class Vehicle {
    constructor(scene, physicsWorld, inputManager, startPos = new THREE.Vector3(0, 5, 0)) {
        this.scene = scene;
        this.physicsWorld = physicsWorld;
        this.inputManager = inputManager;
        this.startPosCannon = new CANNON.Vec3(startPos.x, startPos.y, startPos.z);
        this.startPosThree = startPos;

        // Vehicle dimensions (used for physics mostly)
        this.chassisWidth = 1.1;
        this.chassisHeight = 0.5; // Height of the physics box
        this.chassisLength = 2.2;
        this.wheelRadius = WHEEL_RADIUS;
        this.wheelWidth = WHEEL_WIDTH;

        this.vehicle = null;
        this.chassisBody = null;
        // *** CAR VISUAL CHANGE: Use a Group instead of a single Mesh ***
        this.chassisGroup = null;
        this.wheelMeshes = [];
        // this.wheelBodies = []; // Keep commented out unless needed later

        // Steering state
        this.currentSteering = 0; // Actual current steering value applied

        // Distance tracking
        this.totalDistance = 0;
        this.previousPosition = null;

        this.createPhysicsVehicle();
        this.createVisualVehicle(); // Will now create the group
    }

    createPhysicsVehicle() {
        // Physics shape remains a simple box but with better collision detection
        const chassisShape = new CANNON.Box(new CANNON.Vec3(this.chassisLength * 0.5, this.chassisHeight * 0.5, this.chassisWidth * 0.5));
        this.chassisBody = new CANNON.Body({
            mass: 150,  // Reduced from 180
            material: this.physicsWorld.defaultMaterial,
            collisionFilterGroup: 2,
            collisionFilterMask: 1
        });

        this.chassisBody.addShape(chassisShape);
        this.chassisBody.position.copy(this.startPosCannon);
        this.chassisBody.angularVelocity.set(0, 0, 0);
        this.chassisBody.angularDamping = 0.7;
        this.chassisBody.linearDamping = 0.2;

        // Add this to prevent the physics engine from putting the car to sleep
        this.chassisBody.allowSleep = false;

        // Critical for terrain collision
        this.chassisBody.sleepSpeedLimit = -1;

        this.vehicle = new CANNON.RaycastVehicle({
            chassisBody: this.chassisBody,
            indexRightAxis: 2, indexForwardAxis: 0, indexUpAxis: 1,
        });

        const wheelOptions = {
            radius: this.wheelRadius,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: SUSPENSION_STIFFNESS,
            suspensionRestLength: SUSPENSION_REST_LENGTH,
            frictionSlip: FRICTION_SLIP,
            dampingRelaxation: SUSPENSION_DAMPING,
            dampingCompression: SUSPENSION_COMPRESSION,
            maxSuspensionForce: 100000,
            maxSuspensionTravel: SUSPENSION_TRAVEL,
            customSlidingRotationalSpeed: -30,
            axleLocal: new CANNON.Vec3(0, 0, 1),
            chassisConnectionPointLocal: new CANNON.Vec3(),
            useCustomSlidingRotationalSpeed: true,
            isFrontWheel: false,
        };

        const axleWidth = this.chassisWidth * 0.5;
        // Adjust connection height based on the visual model if needed, but physics box height is key
        const connectionHeight = -this.chassisHeight * 0.4;

        // Front Left (0)
        wheelOptions.chassisConnectionPointLocal.set(this.chassisLength * 0.4, connectionHeight, axleWidth);
        wheelOptions.isFrontWheel = true; this.vehicle.addWheel({ ...wheelOptions });
        // Front Right (1)
        wheelOptions.chassisConnectionPointLocal.set(this.chassisLength * 0.4, connectionHeight, -axleWidth);
        wheelOptions.isFrontWheel = true; this.vehicle.addWheel({ ...wheelOptions });
        // Rear Left (2)
        wheelOptions.chassisConnectionPointLocal.set(-this.chassisLength * 0.4, connectionHeight, axleWidth);
        wheelOptions.isFrontWheel = false; this.vehicle.addWheel({ ...wheelOptions });
        // Rear Right (3)
        wheelOptions.chassisConnectionPointLocal.set(-this.chassisLength * 0.4, connectionHeight, -axleWidth);
        wheelOptions.isFrontWheel = false; this.vehicle.addWheel({ ...wheelOptions });

        this.vehicle.addToWorld(this.physicsWorld);
    }

    createVisualVehicle() {
        // *** CAR VISUAL CHANGE: Create a Group and add parts ***
        this.chassisGroup = new THREE.Group();
        this.scene.add(this.chassisGroup);

        // Main Body (adjust dimensions and position as needed)
        const bodyHeight = 0.4; // Visual height, can differ from physics box
        const bodyGeo = new THREE.BoxGeometry(this.chassisLength, bodyHeight, this.chassisWidth);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.6, roughness: 0.4 });
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        bodyMesh.position.y = bodyHeight / 2; // Position base slightly above origin (0,0,0) of the group
        this.chassisGroup.add(bodyMesh);

        // Cabin (smaller box on top)
        const cabinLength = this.chassisLength * 0.5;
        const cabinWidth = this.chassisWidth * 0.85;
        const cabinHeight = 0.5;
        const cabinGeo = new THREE.BoxGeometry(cabinLength, cabinHeight, cabinWidth);
        const cabinMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.2, roughness: 0.7 });
        const cabinMesh = new THREE.Mesh(cabinGeo, cabinMat);
        cabinMesh.castShadow = true;
        // Position cabin on top of the body, slightly forward
        cabinMesh.position.y = bodyHeight + cabinHeight / 2;
        cabinMesh.position.x = -this.chassisLength * 0.1; // Adjust X offset for placement
        this.chassisGroup.add(cabinMesh);

        // Wheel Meshes (No change needed here)
        const wheelGeo = new THREE.CylinderGeometry(this.wheelRadius, this.wheelRadius, this.wheelWidth, 24);
        wheelGeo.rotateX(Math.PI / 2); // Rotate geometry for correct orientation
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.1, roughness: 0.8 });
        for (let i = 0; i < 4; i++) {
            const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
            wheelMesh.castShadow = true;
            // Add wheels directly to the scene for independent updating
            // Alternatively, could add to chassisGroup if offset correctly, but direct scene add is easier with RaycastVehicle updates
            this.scene.add(wheelMesh);
            this.wheelMeshes.push(wheelMesh);
        }
    }

    update(dt) {
        if (!this.vehicle || !this.chassisBody || !this.chassisGroup) return; // Check for group

        // --- Track Distance ---
        const currentPosition = this.getPosition();
        if (this.previousPosition) {
            // Only count horizontal distance (x-z plane)
            const horizontalDist = Math.sqrt(
                Math.pow(currentPosition.x - this.previousPosition.x, 2) +
                Math.pow(currentPosition.z - this.previousPosition.z, 2)
            );
            this.totalDistance += horizontalDist;
        }
        this.previousPosition = currentPosition.clone();

        // --- Input Handling ---
        let engineForce = 0; let brakeForce = 0; let targetSteering = 0;
        const forwardPressed = this.inputManager.isPressed('forward');
        const backwardPressed = this.inputManager.isPressed('backward');
        const leftPressed = this.inputManager.isPressed('left');
        const rightPressed = this.inputManager.isPressed('right');

        // Engine and Brake
        if (forwardPressed) { engineForce = ENGINE_FORCE_FORWARD; }
        if (backwardPressed) {
            const currentSpeed = this.chassisBody.velocity.length();
            const worldVelocity = this.chassisBody.velocity;
            const forwardDir = new CANNON.Vec3();
            this.chassisBody.vectorToWorldFrame(new CANNON.Vec3(1, 0, 0), forwardDir);
            const dot = forwardDir.dot(worldVelocity);
            if (dot > 0.5 && currentSpeed > 1.0) { brakeForce = BRAKE_FORCE; engineForce = 0; }
            else { engineForce = -ENGINE_FORCE_BACKWARD; brakeForce = 0; }
        }

        // Steering Target
        if (leftPressed) { targetSteering = MAX_STEER_ANGLE; }
        else if (rightPressed) { targetSteering = -MAX_STEER_ANGLE; }
        else { targetSteering = 0; }

        // --- Smooth Steering ---
        const steerLerpFactor = STEERING_SPEED * dt;
        this.currentSteering = lerp(this.currentSteering, targetSteering, steerLerpFactor);
        this.currentSteering = Math.max(-MAX_STEER_ANGLE, Math.min(MAX_STEER_ANGLE, this.currentSteering));

        if (this.inputManager.isPressed('reset')) { this.resetPosition(); return; }

        // Apply forces/steering
        this.vehicle.applyEngineForce(engineForce, 2); this.vehicle.applyEngineForce(engineForce, 3);
        this.vehicle.setBrake(brakeForce, 0); this.vehicle.setBrake(brakeForce, 1);
        this.vehicle.setBrake(brakeForce, 2); this.vehicle.setBrake(brakeForce, 3);
        this.vehicle.setSteeringValue(this.currentSteering, 0);
        this.vehicle.setSteeringValue(this.currentSteering, 1);

        // --- Update Visuals ---
        // *** CAR VISUAL CHANGE: Update the Group's position/rotation ***
        this.chassisGroup.position.copy(this.chassisBody.position);
        this.chassisGroup.quaternion.copy(this.chassisBody.quaternion);

        // Update wheel visuals (No change needed here)
        for (let i = 0; i < this.vehicle.wheelInfos.length; i++) {
            this.vehicle.updateWheelTransform(i);
            const transform = this.vehicle.wheelInfos[i].worldTransform;
            const wheelMesh = this.wheelMeshes[i];
            wheelMesh.position.copy(transform.position);
            wheelMesh.quaternion.copy(transform.quaternion);
        }
    }

    resetPosition() {
        if (!this.vehicle || !this.chassisBody) return;
        console.log("Resetting vehicle position");
        this.chassisBody.position.copy(this.startPosCannon);
        this.chassisBody.quaternion.set(0, 0, 0, 1);
        this.chassisBody.velocity.set(0, 0, 0);
        this.chassisBody.angularVelocity.set(0, 0, 0);
        this.vehicle.applyEngineForce(0, 2); this.vehicle.applyEngineForce(0, 3);
        this.vehicle.setBrake(BRAKE_FORCE * 2, 0); // Apply brake briefly
        this.vehicle.setBrake(BRAKE_FORCE * 2, 1);
        this.vehicle.setBrake(BRAKE_FORCE * 2, 2);
        this.vehicle.setBrake(BRAKE_FORCE * 2, 3);
        this.vehicle.setSteeringValue(0, 0); this.vehicle.setSteeringValue(0, 1);
        this.currentSteering = 0;
        this.chassisBody.wakeUp();

        // Reset distance tracking
        this.totalDistance = 0;
        this.previousPosition = null;

        setTimeout(() => {
            if (this.vehicle) {
                this.vehicle.setBrake(0, 0); this.vehicle.setBrake(0, 1);
                this.vehicle.setBrake(0, 2); this.vehicle.setBrake(0, 3);
            }
        }, 100);
    }

    getPosition() {
        if (!this.chassisBody) { return this.startPosThree || new THREE.Vector3(0,0,0); }
        return new THREE.Vector3(
            this.chassisBody.position.x, this.chassisBody.position.y, this.chassisBody.position.z
        );
    }

    getCurrentSpeedKmH() {
        if (!this.chassisBody) return 0;
        const speedMs = this.chassisBody.velocity.length();
        return Math.round(speedMs * 3.6);
    }

    getDistanceTraveled(unit = 'meters') {
        switch (unit) {
            case 'kilometers':
                return (this.totalDistance / 1000).toFixed(2);
            case 'miles':
                return (this.totalDistance / 1609.34).toFixed(2);
            case 'meters':
            default:
                return Math.round(this.totalDistance);
        }
    }
}


--- new\ayush\js\World.js ---

import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { createNoise2D } from 'simplex-noise';

// --- Constants ---
const TERRAIN_SIZE = 300;
const TERRAIN_RESOLUTION = 150;
const HALF_SIZE = TERRAIN_SIZE / 2;

// Noise parameters (unchanged)
const NOISE_HEIGHT_LARGE = 4;
const NOISE_HEIGHT_MEDIUM = 0.02;
const NOISE_HEIGHT_SMALL = 0.05;
const NOISE_SCALE_LARGE = 0.02;
const NOISE_SCALE_MEDIUM = 0.08;
const NOISE_SCALE_SMALL = 0.15;
const ROAD_FLATTEN_FACTOR = 0.15;

const COLOR_STOPS = [
    { h: -5, color: new THREE.Color(0x4466aa) }, { h: -0.5, color: new THREE.Color(0x6699cc) },
    { h: 0, color: new THREE.Color(0xaa9977) }, { h: 1, color: new THREE.Color(0x66aa66) },
    { h: 3, color: new THREE.Color(0x887766) }, { h: 5, color: new THREE.Color(0xaaaaaa) },
    { h: 8, color: new THREE.Color(0xffffff) },
];

export class World {
    constructor(scene, physicsWorld) {
        this.scene = scene;
        this.physicsWorld = physicsWorld;
        this.noise = createNoise2D();
        this.terrainMesh = null;
        this.terrainBody = null;

        // --- Physics Materials ---
        this.groundMaterial = new CANNON.Material('ground');
        const defaultMaterial = this.physicsWorld.defaultMaterial;

        // Improve friction and reduce sinking by adjusting contact properties
        const groundDefaultContactMaterial = new CANNON.ContactMaterial(
            this.groundMaterial, defaultMaterial, {
                friction: 0.6,           // Increased from 0.4
                restitution: 0.05,      // Reduced from 0.1
                contactEquationStiffness: 1e8,   // Add stiffness
                contactEquationRelaxation: 3     // Add relaxation
            }
        );
        this.physicsWorld.addContactMaterial(groundDefaultContactMaterial);

        // --- Visual Material --- (Shared)
        this.terrainMaterial = new THREE.MeshStandardMaterial({
            wireframe: false,
            flatShading: false,
            metalness: 0.1,
            roughness: 0.9,
            vertexColors: true
        });

        // Create the terrain immediately
        this.createTerrain();

        // Add debug helper for development
        this.createDebugHelpers();
    }

    update(playerPosition) {
        // No dynamic loading needed for single terrain
        // Could add debug visualization if needed here
    }

    createDebugHelpers() {
        // Add a small sphere at origin for reference
        const originHelper = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        originHelper.position.set(0, 0, 0);
        this.scene.add(originHelper);
    }

    createTerrain() {
        console.log("Generating terrain...");
        const segmentSize = TERRAIN_SIZE / TERRAIN_RESOLUTION;

        // Generate height data first (keep this part)
        const heightData = this.generateHeightData();

        // 1. Create visual terrain first (almost identical to your current code)
        console.log("Creating visual mesh...");
        const geometry = new THREE.BufferGeometry();

        const vertices = [];
        const indices = [];
        const colors = [];

        // Build vertex grid
        for (let z = 0; z <= TERRAIN_RESOLUTION; z++) {
            for (let x = 0; x <= TERRAIN_RESOLUTION; x++) {
                // Get world coordinates
                const worldX = -HALF_SIZE + x * segmentSize;
                const worldZ = -HALF_SIZE + z * segmentSize;

                // Get height
                const height = this.calculateHeight(worldX, worldZ);

                // Add vertex
                vertices.push(worldX, height, worldZ);

                // Set color
                const color = this.getColorForHeight(height);
                colors.push(color.r, color.g, color.b);

                // Create triangle indices (same as original)
                if (x < TERRAIN_RESOLUTION && z < TERRAIN_RESOLUTION) {
                    const topLeft = z * (TERRAIN_RESOLUTION + 1) + x;
                    const topRight = topLeft + 1;
                    const bottomLeft = (z + 1) * (TERRAIN_RESOLUTION + 1) + x;
                    const bottomRight = bottomLeft + 1;

                    indices.push(topLeft, bottomLeft, topRight);
                    indices.push(topRight, bottomLeft, bottomRight);
                }
            }
        }

        // Set geometry attributes
        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeVertexNormals();

        // Create visual mesh
        this.terrainMesh = new THREE.Mesh(geometry, this.terrainMaterial);
        this.terrainMesh.receiveShadow = true;
        this.scene.add(this.terrainMesh);

        // 2. Create physics using TRIMESH instead of Heightfield
        console.log("Creating physics trimesh...");

        // Extract vertices and indices from the geometry we just created
        const vertArray = geometry.attributes.position.array;
        const indexArray = geometry.index.array;

        // Create trimesh shape
        const trimeshShape = new CANNON.Trimesh(vertArray, indexArray);

        this.terrainBody = new CANNON.Body({
            mass: 0,  // Static body
            material: this.groundMaterial,
            shape: trimeshShape,
            collisionFilterGroup: 1,
            collisionFilterMask: -1
        });

        // Position at origin since vertices are already in world space
        this.terrainBody.position.set(0, 0, 0);

        // Don't allow sleep
        this.terrainBody.sleepSpeedLimit = -1;
        this.terrainBody.allowSleep = false;

        this.physicsWorld.addBody(this.terrainBody);

        console.log("Terrain created successfully");
    }

    generateHeightData() {
        const data = [];
        const segmentSize = TERRAIN_SIZE / TERRAIN_RESOLUTION;

        // Create heightmap using exact same algorithm for both physics and visual
        for (let i = 0; i <= TERRAIN_RESOLUTION; i++) {
            data[i] = [];
            for (let j = 0; j <= TERRAIN_RESOLUTION; j++) {
                const worldX = -HALF_SIZE + i * segmentSize;
                const worldZ = -HALF_SIZE + j * segmentSize;
                data[i][j] = this.calculateHeight(worldX, worldZ);
            }
        }

        return data;
    }

    calculateHeight(worldX, worldZ) {
        let height = 0;
        height += this.noise(worldX * NOISE_SCALE_LARGE, worldZ * NOISE_SCALE_LARGE) * NOISE_HEIGHT_LARGE;
        height += this.noise(worldX * NOISE_SCALE_MEDIUM, worldZ * NOISE_SCALE_MEDIUM) * NOISE_HEIGHT_MEDIUM;
        height += this.noise(worldX * NOISE_SCALE_SMALL, worldZ * NOISE_SCALE_SMALL) * NOISE_HEIGHT_SMALL;
        const flatten = Math.exp(-Math.pow(height, 2) * ROAD_FLATTEN_FACTOR);
        height *= flatten;
        return height;
    }

    getColorForHeight(height) {
        let vertColor = new THREE.Color(COLOR_STOPS[0].color);
        for (let stop = 0; stop < COLOR_STOPS.length - 1; stop++) {
            const currentStop = COLOR_STOPS[stop];
            const nextStop = COLOR_STOPS[stop + 1];
            if (height >= currentStop.h && height < nextStop.h) {
                const t = (height - currentStop.h) / (nextStop.h - currentStop.h);
                const clampedT = Math.max(0, Math.min(1, t));
                vertColor.lerpColors(currentStop.color, nextStop.color, clampedT);
                return vertColor;
            }
        }
        if (height >= COLOR_STOPS[COLOR_STOPS.length - 1].h) {
            vertColor.copy(COLOR_STOPS[COLOR_STOPS.length - 1].color);
        }
        return vertColor;
    }
}


--- new\ayush\README.md ---

```bash
npx http-server . -o
```

```bash
npm install --save-dev cannon-es-debugger
```

```bash
npm install --save-dev vite
```
```bash
npm install simplex-noise
```


--- new\ayush\style.css ---

body {
    margin: 0;
    overflow: hidden; /* Prevent scrollbars */
    background-color: #000;
    color: white;
    font-family: Arial, sans-serif;
}

#c {
    display: block; /* Remove potential extra space below canvas */
}

#ui-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    padding: 10px;
    box-sizing: border-box; /* Include padding in width */
    pointer-events: none; /* Allow clicking through UI */
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

#info {
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 0.9em;
    max-width: 200px; /* Limit width */
}

#speedometer {
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 1.1em;
    font-weight: bold;
    margin-right: 10px; /* Add some margin if needed */
}

#speed-value {
    min-width: 40px; /* Reserve space for speed value */
    display: inline-block;
    text-align: right;
}

#distance-meter {
    position: absolute;
    bottom: 50px;
    left: 20px;
    color: white;
    font-family: 'Arial', sans-serif;
    font-size: 18px;
    text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
}


/* Add this to your style.css */
#stats-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 5px;
}

#speedometer {
    background-color: transparent;
    padding: 0;
    margin: 0;
    font-size: 1.1em;
    font-weight: bold;
}

#distance-meter {
    position: static;
    font-size: 1em;
    text-shadow: none;
}


--- new\ayush\vite.config.js ---

export default {
  server: {
    allowedHosts: ['scope-tent-tips-freebsd.trycloudflare.com']
  }
};
